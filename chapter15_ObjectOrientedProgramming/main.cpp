#include <iostream>

using namespace std;



/* 
* 面向对象程序设计(object-oriented programming)的核心思想是：数据抽象(类)、继承、和动态绑定
* 使用数据抽象，我们可以将类的接口与实现分离；
* 使用继承，可以定义相似的类型并对其相似关系进行建模；
* 使用动态绑定，可以在一定程度上忽略类似类型的区别； 
*/

int main()
{
	/* 继承(inheritance) */
	//继承练习在一起的类构成一种层次关系。通常在层次关系的底部有一个基类(base class)，其他类则直接或间接地从基类继承而来，这些继承得到的类被称为派生类(derived class);
	//基类负责定义在层次关系中所有类共同拥有的成员，而且每个派生类定义各自特有的成员。
	//基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于这些函数，基类希望它的派生类各自定义适合自己的版本，此时基类就将这些函数声明成虚函数(virtual function)。
	//派生类必须使用类派生列表（class derivation list）明确指出他是从哪个，哪些基类继承而来；

	//因为Bulk_quote的派生列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象来用
	//派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但不是非得这么做。C++11标准允许派生类显示的著名它使用哪个成员函数改写基类的虚函数，在该函数的形参之后加上override关键字。

	/* 动态绑定（dynamic binding） */
#if 0
	//通过使用动态绑定，我们能用同一段代码分别处理Quote和Bulk_quote的对象。
	//计算并打印销售给定数量的某种书籍所得的费用
	double print_total(ostream &os, const Quote &item, size_t n)
	{
		//传入item形参的对象类型调用Quote::net_prise
		//或者Bulk_quote::net_ptice
		double ret = item.net_prise(n);
		os << "ISBN: " << item.isbn()		//调用Quote::isbn
			<< " # sold: " << n << "total due: " << ret << endl;
		return ret;
	}
	//因为函数item的新参是基类Quote的一个引用，多以我们既能使用基类Quote的对象调用该函数，也是使用派生类Bulk_quote的对象调用它，因为是运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定（run-time binding）；
#endif
	//基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

	/* 成员函数与继承 */
	//派生类可以继承其基类的成员，当遇到如net_price这样与类型相关的操作的时候，培盛磊需要对这些操作提供自己的定义以复改（override）从基站继承而来的旧定义
	//有关虚函数的其他规则（page528）

	/* 访问控制与继承 */
	//和其他使用基类的代码一样，派生类只能访问共有成员，不能访问私有成员；但是有这样一种成员，基类希望他的派生类有权访问该成员，同时禁止其他用户访问，我们用受保护的（protected）访问运算符说明

	/* 派生类对象以及派生类向基类的类型转换 */
	//派生类中含有基类的数据，因为在派生类中有其基类对应的组成部分，所以我们把派生类的对象当成基类的对象来用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。
#if 0

	Quote item;					//基类对象
	Bulk_quote bulk;			//派生类对象
	Quote* p = &item;			//p指向Quote对象
	p = &bulk;					//p指向bulk的Quote部分
	Quote& r = bulk;			//r绑定到bulk的Quote部分
	//这种转换称为派生类向基类的转换（derived-to-base），隐式的执行，我们可以把派生类对象或者派生类对象的引用或者指针用在需要基类的地方
#endif
	//每个类控制它自己的成员初始化过程
	//派生类可以访问基类的公有成员和受保护成员
	//直接基类（direct base），间接基类（indirect base）

	/* 防止继承的产生 */
	class NoDerived final {};	//在类名后加final，其不能作为基类

	//这种转换称为派生类向基类的转换（derived-to-base），只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换,转换之后该构造函数只能处理基类自己的成员

	/* 虚函数 */
	//我们必须为每一个虚函数都提供定义，而不管他们是否被用到了
	//OOP的核心思想是多态性（polymorphism），我们把具有继承关系的多个类型称为多态类型；
	//虚函数也有默认实参，基类和派生类中的默认实参最好是一样的
	//某些情况下我们可以通过作用域运算符强迫执行虚函数的某个版本
#if 0
	//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
	double undiscounted = baseP->Quote::net_price(42);
	//通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避函数的机制
#endif
	//有纯虚函数，是抽象基类，不能定义对象.纯虚函数（pure virtual），在声明语句的的分号之前书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数申明语句处。

	/* 重构 */
	//在Quote的继承体系中增加Disc_quote类是重构（refactoring）的一个典型示例。重构负责重新设计类的体系移变将操作和数据从一个类中移动到另外一个类中。对于面向对象的程序来说，重构是很普遍的现象，不过需要注意的是，一旦类被重构，我们就要重新编辑含有这些类的代码。

	/* 访问控制于继承：每个类控制着自己成员的初始化过程，此外每个类还控制着其他成员对于派生类来说是否是可访问的（accessible） */
	//某个类对其继承而来的成员的访问权限受到两个因素的影响：一是在基类中该成员的访问说明符，二是在派生列表中的访问说明符(page544)
	//关键概念：类的设计与受保护的成员

	//友元关系不能继承

	//有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明，改变可访问性
	//使用class关键字定义的派生类是私有继承的，而struct关键字定义的派生类是公有继承的

	/* 继承中的类作用域 */
	//当存在继承关系时候，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器继续在外层的做哟关于中寻找定义，若名字一样，派生类（内层作用域）的名字将隐藏定义在基类（外层作用域）的名字；当然，我们还是可以通过作用域运算符使用一个被隐藏的成员。
	//名字查找先于类型检查，如果名字找到了，但是类型不对，不会继续查找而是报错

	/* 构造函数与拷贝控制 */
	//虚析构函数：继承关系对基类拷贝控制最直接的影响应该是基类通常应该定义一个虚析构函数，和其他虚函数一样，析构函数的虚函数也会继承，这样我们就能动态分配体系中的对象了
	// = delete 被删除的函数，禁止使用编译器默认生成的函数
	//当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

	//与拷贝与构造函数一样，派生类的赋值运算符也必须显示的为基类部分赋值
	//派生类能够重用直接基类定义的构造函数，但是类不能继承默认、拷贝和移动构造函数，可以使用using::声明

	/* 容器与继承 */
	//当我们使用容器存放继承体系中的对象的时候，通常必须采取间接存储的方式，当派生类对象被赋值给基类对象时，其中的培盛磊部分将被切除，因此容器和存在继承关系的类型无法兼容
	//我们可以在容器中存放智能指针而非对象
#if 0
	vector<shared_ptr<Quote>> basket;
	basked.push_back(make_shared<Quote>("0-201-82470-1", 50));
	basked.push_back(make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25));
	//调用Quote定义的版本；打印562.5，即在15*&50中扣除掉折扣余额
	cout << basket.back()->net_price(15) << endl;
#endif

	//对于c++面向对象编程来说，一个悖论就是我们无法直接用对象进行面向对象编程。相反我们必须用指针和引用

	//隐藏指针






















	return 0;
}